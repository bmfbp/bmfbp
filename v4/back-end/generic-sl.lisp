(in-package :arrowgrams/compiler)

#+nil(eval-when (:compile-toplevel)

  (defparameter *generic-rules*
    "
= <ir> 
  :lpar
    <top-name>
    <kind>
    <metadata>
    <inputs> 
    <outputs> 
    <react> 
    <first-time> 
    <part-declarations> 
    <wiring>
  :rpar

= <top-name>
  :string

= <inputs> 
  [ ?symbol :symbol symbol-must-be-nil | ?lpar :lpar <pin-list> :rpar]

= <outputs> 
  [ ?symbol :symbol symbol-must-be-nil | ?lpar :lpar <pin-list> :rpar]

= <part-declarations> 
  :lpar <part-decl-list> :rpar

= <wiring> 
  :lpar
    <wire-list>
  :rpar

= <pin-list> 
  <ident-list>

= <ident-list> 
  :string [ ?string <ident-list>]

= <part-decl-list> 
  [ ?lpar <part-decl> [ ?lpar <part-decl-list> ] | ! ]

= <part-decl>
  :lpar <name> <kind> <inputs> <outputs> <react> <first-time> :rpar

= <name>
  :string

= <metadata>
  [ ?symbol :symbol symbol-must-be-nil error-no-metadata | ?string :string ]

= <kind>
  :string

= <react>
  :string

= <first-time>
  :string

= <wire-list>
  <wire> [ ?lpar <wire-list> ] 

= <wire>
  :lpar
    :integer
    :lpar <part-pin-list> :rpar
    :lpar <part-pin-list> :rpar
  :rpar

= <part-pin-list> 
  :lpar <part> <pin> :rpar 
  [ ?lpar <part-pin-list>]

= <part>
  :string
= <pin>
  :string
"
    )

#+nil  (defmacro xxx () (sl:parse *generic-rules* "-GENERIC")))

#+nil (xxx)

#+nil(sl:parse *generic-rules* "-GENERIC")

(PROGN
 (DEFMETHOD IR-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'IR-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :LPAR)
     (CALL-RULE P #'TOP-NAME-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'KIND-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'METADATA-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'INPUTS-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'OUTPUTS-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'REACT-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'FIRST-TIME-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'PART-DECLARATIONS-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'WIRING-GENERIC DEPTH CURRENT-METHOD)
     (MUST-SEE P :RPAR)))
 (DEFMETHOD TOP-NAME-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'TOP-NAME-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :STRING)))
 (DEFMETHOD INPUTS-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'INPUTS-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (COND
      ((LOOK-AHEAD P :SYMBOL) (MUST-SEE P :SYMBOL)
       (CALL-EXTERNAL P #'SYMBOL-MUST-BE-NIL DEPTH CURRENT-METHOD))
      ((LOOK-AHEAD P :LPAR) (MUST-SEE P :LPAR)
       (CALL-RULE P #'PIN-LIST-GENERIC DEPTH CURRENT-METHOD)
       (MUST-SEE P :RPAR)))))
 (DEFMETHOD OUTPUTS-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'OUTPUTS-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (COND
      ((LOOK-AHEAD P :SYMBOL) (MUST-SEE P :SYMBOL)
       (CALL-EXTERNAL P #'SYMBOL-MUST-BE-NIL DEPTH CURRENT-METHOD))
      ((LOOK-AHEAD P :LPAR) (MUST-SEE P :LPAR)
       (CALL-RULE P #'PIN-LIST-GENERIC DEPTH CURRENT-METHOD)
       (MUST-SEE P :RPAR)))))
 (DEFMETHOD PART-DECLARATIONS-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'PART-DECLARATIONS-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :LPAR)
     (CALL-RULE P #'PART-DECL-LIST-GENERIC DEPTH CURRENT-METHOD)
     (MUST-SEE P :RPAR)))
 (DEFMETHOD WIRING-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'WIRING-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :LPAR)
     (CALL-RULE P #'WIRE-LIST-GENERIC DEPTH CURRENT-METHOD)
     (MUST-SEE P :RPAR)))
 (DEFMETHOD PIN-LIST-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'PIN-LIST-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (CALL-RULE P #'IDENT-LIST-GENERIC DEPTH CURRENT-METHOD)))
 (DEFMETHOD IDENT-LIST-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'IDENT-LIST-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :STRING)
     (COND
      ((LOOK-AHEAD P :STRING)
       (CALL-RULE P #'IDENT-LIST-GENERIC DEPTH CURRENT-METHOD)))))
 (DEFMETHOD PART-DECL-LIST-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'PART-DECL-LIST-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (COND
      ((LOOK-AHEAD P :LPAR)
       (CALL-RULE P #'PART-DECL-GENERIC DEPTH CURRENT-METHOD)
       (COND
        ((LOOK-AHEAD P :LPAR)
         (CALL-RULE P #'PART-DECL-LIST-GENERIC DEPTH CURRENT-METHOD))))
      (T))))
 (DEFMETHOD PART-DECL-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'PART-DECL-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :LPAR)
     (CALL-RULE P #'NAME-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'KIND-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'INPUTS-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'OUTPUTS-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'REACT-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'FIRST-TIME-GENERIC DEPTH CURRENT-METHOD)
     (MUST-SEE P :RPAR)))
 (DEFMETHOD NAME-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'NAME-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :STRING)))
 (DEFMETHOD METADATA-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'METADATA-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (COND
      ((LOOK-AHEAD P :SYMBOL) (MUST-SEE P :SYMBOL)
       (CALL-EXTERNAL P #'SYMBOL-MUST-BE-NIL DEPTH CURRENT-METHOD)
       (CALL-EXTERNAL P #'ERROR-NO-METADATA DEPTH CURRENT-METHOD))
      ((LOOK-AHEAD P :STRING) (MUST-SEE P :STRING)))))
 (DEFMETHOD KIND-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'KIND-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :STRING)))
 (DEFMETHOD REACT-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'REACT-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :STRING)))
 (DEFMETHOD FIRST-TIME-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'FIRST-TIME-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :STRING)))
 (DEFMETHOD WIRE-LIST-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'WIRE-LIST-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (CALL-RULE P #'WIRE-GENERIC DEPTH CURRENT-METHOD)
     (COND
      ((LOOK-AHEAD P :LPAR)
       (CALL-RULE P #'WIRE-LIST-GENERIC DEPTH CURRENT-METHOD)))))
 (DEFMETHOD WIRE-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'WIRE-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :LPAR)
     (MUST-SEE P :INTEGER)
     (MUST-SEE P :LPAR)
     (CALL-RULE P #'PART-PIN-LIST-GENERIC DEPTH CURRENT-METHOD)
     (MUST-SEE P :RPAR)
     (MUST-SEE P :LPAR)
     (CALL-RULE P #'PART-PIN-LIST-GENERIC DEPTH CURRENT-METHOD)
     (MUST-SEE P :RPAR)
     (MUST-SEE P :RPAR)))
 (DEFMETHOD PART-PIN-LIST-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'PART-PIN-LIST-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :LPAR)
     (CALL-RULE P #'PART-GENERIC DEPTH CURRENT-METHOD)
     (CALL-RULE P #'PIN-GENERIC DEPTH CURRENT-METHOD)
     (MUST-SEE P :RPAR)
     (COND
      ((LOOK-AHEAD P :LPAR)
       (CALL-RULE P #'PART-PIN-LIST-GENERIC DEPTH CURRENT-METHOD)))))
 (DEFMETHOD PART-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'PART-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :STRING)))
 (DEFMETHOD PIN-GENERIC ((P PARSER) &OPTIONAL (DEPTH 0))
   (LET ((CURRENT-METHOD 'PIN-GENERIC))
     (IN-RULE P DEPTH CURRENT-METHOD)
     (MUST-SEE P :STRING))))
