= esa-dsl
$   (emit p "(in-package :arrowgrams/build)~%~%")
  @type-decls
  @kinds
  @aux
  @scripts
  EOF

- keyword-symbol
  [ ?SYMBOL
    [ ?SYMBOL/type ^ok
    | ?SYMBOL/kind ^ok
    | ?SYMBOL/end ^ok
    | ?SYMBOL/proto ^ok
    | ?SYMBOL/delegate ^ok
    | ?SYMBOL/method ^ok
    | ?SYMBOL/script ^ok
    | ?SYMBOL/aux ^ok
    | ?SYMBOL/let ^ok
    | ?SYMBOL/set ^ok
    | ?SYMBOL/map ^ok
    | ?SYMBOL/in ^ok
    | ?SYMBOL/loop ^ok
    | ?SYMBOL/if ^ok
    | ?SYMBOL/then ^ok
    | ?SYMBOL/else ^ok
    | * ^fail
    ]
  | * ^fail
  ]

- non-keyword-symbol
  [ ?SYMBOL
    [ &keyword-symbol ^fail
    | * ^ok
    ]
  | * ^fail
  ]

= type-decls
  {[ ?SYMBOL/type @type-decl
   | * >
  ]}

= type-decl
  SYMBOL/type @esa-symbol

= kinds
  {[ ?SYMBOL/kind @kind
   | * >
  ]}

= aux
  {[ ?SYMBOL/aux @auxiliary
   | * >
  ]}

= scripts
  {[ ?SYMBOL/script @script-definition
   | * >
  ]}

= kind
  SYMBOL/kind
  @esa-symbol
       set-current-class
$      (emit p "~&(defclass ~a ()~%(" (atext p))
$      (clear-method-stream p)
  {[ ?SYMBOL/script @script-decl
   | ?SYMBOL/method @method-decl
   | ?SYMBOL/delegate @delegate-def
   | ?SYMBOL/field @field-decl
   | ?SYMBOL/proto @proto-decl
   | * >
  ]}
$      (emit p "))~%")
$      (emit p "~%(defmethod create-~a () (make-instance '~a))" (current-class p) (current-class p))
       emit-methods
  SYMBOL/end SYMBOL/kind

= auxiliary
  SYMBOL/aux
  @esa-symbol
     set-current-class
  {[ ?SYMBOL/method @method-decl
   | ?SYMBOL/script @delegate-def
   | ?SYMBOL/script @script-decl
   | * >
  ]}
    emit-methods
  SYMBOL/end SYMBOL/aux

= field-decl
  SYMBOL/field
  [ ?SYMBOL/map @map-decl
  | &non-keyword-symbol @esa-symbol
$     (emit p "~&(~a :accessor ~a)~%" (atext p) (atext p))
  | *
  ]

= proto-decl
  SYMBOL/proto
  @esa-symbol
$     (emit p "~&(proto :accessor proto :initform (make-instance '~a))~%" (atext p))

= delegate-def
  SYMBOL/delegate @esa-symbol
  push-symbol
$      (emit-to-method-stream p "~%(defmethod ~a (self" (atext p))
  @typed-formals
$      (emit-to-method-stream p ")") ;; close parameter list
  @return-type
$      (emit-to-method-stream p " (~a proto))" (pop-symbol p))
  
= method-decl
  SYMBOL/method @esa-symbol
$      (emit-to-method-stream p "~%(defgeneric ~a (self" (atext p))
  @typed-formals
$      (emit-to-method-stream p ")") ;; close parameter list
  @return-type
$      (emit-to-method-stream p ")") ;; close generic

  
= script-decl
  SYMBOL/script @esa-symbol
$      (emit-to-method-stream p "~%(defgeneric ~a #|script|# (self" (atext p))
  @typed-formals
$      (emit-to-method-stream p ")")
  @return-type
$      (emit-to-method-stream p ")") ;; close generic

= map-decl
  SYMBOL/map 
  @esa-symbol
$     (emit p "~&(~a :accessor ~a :initform " (atext p) (atext p))
$     (emit p "(empty-map '~a))~%" (atext p))
  
= typed-formals
  [ ?'(' '(' type-list ')'
  | *
  ]

= type-list
  @esa-symbol
$     (emit-to-method-stream p " ~a" (atext p))
  {[ &non-keyword-symbol @esa-symbol
$     (emit-to-method-stream p " ~a" (atext p))
   | * >
  ]}
  
= return-type
  [ ?'>' '>' '>'
         [ ?SYMBOL/map SYMBOL/map @esa-symbol
$            (emit-to-method-stream p " #|returns map ~a|# " (atext p))
         | * @esa-symbol
$            (emit-to-method-stream p " #|returns ~a|# " (atext p))
]
  | *
  ]
  
= script-definition
  SYMBOL/script
  @qualified-symbol
  set-current-method
$      (emit p "~%(defmethod ~a #|script|# ((self ~a)" (atext p) (current-class p))
  @formals
$      (emit p ")")  
  @return-type
  @script-body
$      (emit p ")#|end script|#~%")
  SYMBOL/end SYMBOL/script

= formals
  {[ ?'(' '(' untyped-formals ')'
   | * >
  ]}

= untyped-formals
  {[ &non-keyword-symbol @esa-symbol 
$    (emit p " ~a " (atext p))
   | * >
  ]}

= script-body
  {
$     (emit p "~%")
   [ ?SYMBOL/let @let-statement
   | ?SYMBOL/map @map-statement
   | ?SYMBOL/set @set-statement
   | ?SYMBOL/if @if-statement
   | ?SYMBOL/loop @loop-statement
   | ?SYMBOL/exit-when @exit-when-statement
   | ?'>' @return-statement
   | ?'@' @esa-expr
   | &non-keyword-symbol @esa-expr
   | * >
  ]}

= let-statement
  SYMBOL/let
   @esa-symbol
$      (emit p "(let ((~a " (atext p))
   '=' 
   @esa-expr
$      (emit p "))")
   SYMBOL/in 
   @script-body
$      (emit p ")#|end let|#")   
   SYMBOL/end SYMBOL/let

= set-statement
  SYMBOL/set
$      (emit p "(setf ")
   @esa-expr
   '=' 
   @esa-expr
$      (emit p ")")
  
= map-statement
  SYMBOL/map @esa-symbol
$      (emit p "(dolist (~a " (atext p))
  '='
  @esa-expr
$      (emit p ")")
  SYMBOL/in @script-body
$      (emit p ")#|end map|#")   
  SYMBOL/end SYMBOL/map

= loop-statement
  SYMBOL/loop
$     (emit p "(loop")
    @script-body
$     (emit p ")#|end loop|#")
  SYMBOL/end SYMBOL/loop
  
= exit-when-statement
  SYMBOL/exit-when
    @esa-expr
$     (emit p "(when ~a (return))" (atext p))

= if-statement
  SYMBOL/if
$    (emit p "(if ")
    @esa-expr
  SYMBOL/then
$    (emit p "~%(progn")
    @script-body
$    (emit p ")")
  [ ?SYMBOL/else SYMBOL/else
$    (emit p "~%(progn")
     @script-body
$    (emit p ")#|end else|#")
  | *
  ]
$    (emit p ")#|end if|#")
  SYMBOL/end SYMBOL/if
  
= script-call
  '@' @qualified-symbol
$    (emit p "(call-script p ~a)" (atext p))
  
= method-call
  @qualified-symbol
$    (emit p "(call-external p ~a)" (atext p))

= return-statement
  '>' '>' @esa-symbol
$    (emit p "(return-from ~a ~a)" (current-method p) (atext p))

= qualified-symbol
  @esa-symbol
    set-current-class
  [ ?'.' @dotted-symbol
  | *
  ]

= qualifiers
  {[ ?'.' @dotted-symbol
   | * >
  ]}
  
= dotted-symbol
  '.' @esa-symbol

= esa-symbol
  [ &non-keyword-symbol
    clear-saved-text
    SYMBOL
    @esa-symbol-follow
  | *
  ]

= esa-symbol-follow
  save-text
  {[ ?'/' '/' combine-text SYMBOL combine-text
   | ?'-' '-' combine-text SYMBOL combine-text
   | ?'?' '?' combine-text >
   | * >
  ]}

= esa-expr
  expr-stack-open
  [ ?'@' '@' set-call-rule-flag | * ]
  @esa-symbol
  push-symbol-onto-expr-stack
  {[ ?'.' @dotted-symbol push-symbol-onto-expr-stack
   | * >
  ]}
  emit-expr-stack
  @actuals
  expr-stack-close

= actuals
 [ ?'(' '(' {[ &non-keyword-symbol @esa-symbol emit-expr-actual | * > ]} ')'
 | *
 ]

