= esa-dsl
$   (emit p "(in-package :arrowgrams/esa)")
  reset-classes
  @type-decls
  @situations
  @classes
  @whens-and-scripts
  EOF

- keyword-symbol
  [ ?SYMBOL
    [ ?SYMBOL/type ^ok
    | ?SYMBOL/class ^ok
    | ?SYMBOL/create ^ok
    | ?SYMBOL/end ^ok
    | ?SYMBOL/method ^ok
    | ?SYMBOL/script ^ok
    | ?SYMBOL/let ^ok
    | ?SYMBOL/set ^ok
    | ?SYMBOL/map ^ok
    | ?SYMBOL/in ^ok
    | ?SYMBOL/loop ^ok
    | ?SYMBOL/if ^ok
    | ?SYMBOL/then ^ok
    | ?SYMBOL/else ^ok
    | ?SYMBOL/when ^ok
    | ?SYMBOL/situation ^ok
    | ?SYMBOL/or ^ok
    | ?SYMBOL/true ^ok
    | ?SYMBOL/false ^ok
    | ?SYMBOL/exit-map ^ok
    | * ^fail
    ]
  | * ^fail
  ]

- non-keyword-symbol
  [ ?SYMBOL
    [ &keyword-symbol ^fail
    | * ^ok
    ]
  | * ^fail
  ]

= type-decls
  {[ ?SYMBOL/type @type-decl
   | * >
  ]}

= type-decl
  SYMBOL/type @esa-symbol

= situations
  {[ ?SYMBOL/situation @situation | * > ]}

= situation
  SYMBOL/situation SYMBOL

= classes
  {[ ?SYMBOL/class @class-def
   | * >
  ]}

= whens-and-scripts
  {[ ?SYMBOL/script @script-definition
   | ?SYMBOL/when @when-declaration
   | * >
  ]}

= class-def
  SYMBOL/class
  @esa-symbol
       set-current-class
  open-new-class-descriptor
  @field-decl-begin @field-decl
  {[ &field-decl-begin @field-decl
   | * >
  ]}
  SYMBOL/end SYMBOL/class
  close-new-class-descriptor

- field-decl-begin
  [ ?SYMBOL/map ^ok
  | &non-keyword-symbol ^ok
  | * ^fail
 ]

= field-decl
  [ ?SYMBOL/map
    SYMBOL/map 
    @esa-symbol
    open-new-method-descriptor
    set-current-method-as-map
  | &non-keyword-symbol @esa-symbol
    open-new-method-descriptor
  ]
  close-new-method-descriptor

= when-declaration
  SYMBOL/when
  @situation-ref {[ ?SYMBOL/or @or-situation | * > ]}
  @class-ref
  open-existing-class-descriptor
  {[ ?SYMBOL/script @script-declaration
   | ?SYMBOL/method @method-declaration
   | * >
  ]}
  SYMBOL/end SYMBOL/when
  close-existing-class-descriptor

= situation-ref
  @esa-symbol % should be checked to be a situation

= or-situation
  SYMBOL/or @situation-ref
  
= class-ref
  @esa-symbol  % should be checked to be a kind

= method-declaration % "when" is always a declaration
  open-new-method-descriptor
  SYMBOL/method @esa-symbol
  @generic-typed-formals
  @optional-return-type-declaration
  method-attach-to-class
  close-new-method-descriptor
  
= script-declaration  % this is a declaration of scripts to be defined
  SYMBOL/script @esa-symbol
  open-new-method-descriptor
  @generic-typed-formals
  @optional-return-type-declaration
  method-attach-to-class
  close-new-method-descriptor

= generic-typed-formals
   reset-formals-index
  [ ?'(' '(' generic-type-list ')'
  | *
  ]

= generic-type-list
  @esa-symbol
  add-formal-type-at-index
  inc-formals-index
  {[ &non-keyword-symbol @esa-symbol
     add-formal-type-at-index
     inc-formals-index
   | * >
  ]}

= optional-return-type-declaration
  [ ?'>' '>' '>'
         [ ?SYMBOL/map SYMBOL/map @esa-symbol
           push-new-return-type
           set-return-type-as-map
         | * @esa-symbol
           push-new-return-type

  ]
  add-return-type-to-method
  pop-new-return-type
  | *
  ]



= script-definition
  SYMBOL/script
  @esa-symbol
  open-existing-class-descriptor
  @qualified-symbol
  open-existing-method-descriptor
  @optional-formals-definition
  @optional-return-type-definition
  @script-body
  close-existing-method-descriptor
  close-existing-class-descriptor
  SYMBOL/end SYMBOL/script

= optional-formals-definition
  reset-formals-index
  {[ ?'(' '(' untyped-formals-definition ')'
   | * >
  ]}

= untyped-formals-definition
  {[ &non-keyword-symbol @esa-symbol
     % index and type
     add-formal-name-at-index
     inc-formals-index
   | * >
  ]}
  
= optional-return-type-definition  % should check that return type matches the definition
  [ ?'>' '>' '>'
         [ ?SYMBOL/map SYMBOL/map @esa-symbol
         | * @esa-symbol

  ]
  | *
  ]  
  
= script-body
  {
$     (emit p "~%")
   [ ?SYMBOL/let @let-statement
   | ?SYMBOL/map @map-statement
   | ?SYMBOL/exit-map @exit-map-statement
   | ?SYMBOL/set @set-statement
   | ?SYMBOL/create @create-statement
   | ?SYMBOL/if @if-statement
   | ?SYMBOL/loop @loop-statement
   | ?SYMBOL/exit-when @exit-when-statement
   | ?'>' @return-statement
   | ?'@' @esa-expr
   | &non-keyword-symbol @esa-expr
   | * >
  ]}

= let-statement
  SYMBOL/let
   @esa-symbol
$      (emit-code p "~&let ~a =" (atext p))
   '='
   [ ?SYMBOL/map SYMBOL/map | * ]
   @esa-expr
$      (emit-code p "; /* let */ ~%")
   SYMBOL/in 
   @script-body
   SYMBOL/end SYMBOL/let

= create-statement
  SYMBOL/create
   @esa-symbol
$      (emit-code p "~&let ~a = " (atext p))
   '=' 
   [ ?SYMBOL/map SYMBOL/map | * ]
   [ ?'*' '*'
     @class-ref
$      (emit-code p "new *~a(); /* create* */ ~%" (atext p))
   | *
   @class-ref
$      (emit-code p "new ~a(); /* create */ ~%" (atext p))
   ]
   SYMBOL/in 
   @script-body
   SYMBOL/end SYMBOL/create

= set-statement
  SYMBOL/set
   @esa-expr
   '=' 
$      (emit-code p " = ")
   @esa-expr
$      (emit-code p " ; /* set */~% ")
  
= map-statement
  SYMBOL/map @esa-symbol
$      (emit-code p "~&for ~a in " (atext p))
  '='
  @esa-expr
$      (emit-code p ") {~%")
  SYMBOL/in @script-body
$      (emit-code p "} /* end map */ ~%")
  SYMBOL/end SYMBOL/map

= exit-map-statement
  SYMBOL/exit-map
$     (emit-code p "~&return; /* exit map */ ~%")

= loop-statement
  SYMBOL/loop
$     (emit-code p "~&while (true) {~%")
    @script-body
$     (emit-code p "~&} /*end loop*/ ~%")
  SYMBOL/end SYMBOL/loop
  
= exit-when-statement
  SYMBOL/exit-when
$     (emit-code p "~&if (")
    @esa-expr
$     (emit-code p ") return; /* exit-when */ ~%")

= if-statement
  SYMBOL/if
$    (emit-code p "~&if (")
    @esa-expr
$    (emit-code p ") {~%")
  SYMBOL/then
    @script-body
$    (emit-code p "~&}  /* end if */ ~%")
  [ ?SYMBOL/else SYMBOL/else
$    (emit-code p "~&else {~%")
     @script-body
$    (emit-code p "~&} /* end else */ ~%")
  | *
  ]
  SYMBOL/end SYMBOL/if

= script-call
  '@' @qualified-symbol
$    (emit-code p "~&this.~a(); /* call script */ ~%" (atext p))

= method-call
  @qualified-symbol
$    (emit-code p "~&this.~a(); /* call method */ ~%" (atext p))

= return-statement
  '>' '>'
  [ ?SYMBOL/true SYMBOL/true
$                (emit-code p "~&return true; /* return true */ ~%")
  | ?SYMBOL/false SYMBOL/false
$                (emit-code p "~&return false; /* return false */ ~%")
  | * @esa-symbol
$                (emit-code p "~&return ~a; /* return value */ ~%" (atext p))
  ]

= qualified-symbol
  @esa-symbol
  [ ?'.' @dotted-symbol
  | *
  ]

= qualifiers
  {[ ?'.' @dotted-symbol
   | * >
  ]}
  
= dotted-symbol
  '.' 
  symbol-enstack-apply
  @esa-symbol
  symbol-pop-apply

= esa-symbol
  [ &non-keyword-symbol
    symbol-open
    SYMBOL
    symbol-append-symbol
    @esa-symbol-follow
    symbol-close
  | *
  ]

= esa-symbol-follow
  save-text
  {[ ?'/' '/' 
     symbol-append-slash 
     SYMBOL
     symbol-append-symbol
   | ?'-' '-' 
     symbol-append-dash
     SYMBOL
     symbol-append-symbol
   | ?'?' '?'
     symbol-append-question
      >
   | ?CHARACTER/' CHARACTER/' 
     symbol-append-primed
     >
   | * >
  ]}

= esa-expr
  expr-open
  [ ?'@' '@' | * ]  % ignore @ (script call symbol)
  [ ?SYMBOL/true SYMBOL/true symbol-open symbol-append-true symbol-close
  | ?SYMBOL/false SYMBOL/false symbol-open symbol-append-false symbol-close
  | *
    @esa-symbol
    {[ ?'.' @dotted-symbol
     | * >
    ]}
    expr-set-functor
    @actuals
    expr-close
   ]

= actuals
 [ ?'(' '('
   {[ &non-keyword-symbol 
     expr-open
      @esa-expr
      expr-add-as-argument
      expr-close
    | * > 
    ]}
    ')'
 | * 
 ]

