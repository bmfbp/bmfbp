* overview
  This directory contains that ESA (Encapsulated Software Assets) transpiler.
  The transpile is built using (2) pasm and (1) the stack language transpiler.
  Pasm is used to create dsl.lisp from esa.pasm.
  Stack-dsl is used to create exprtypes.lisp from exprtypes.dsl.
  The final ESA transpiler is used in ../esa.
  The final ESA transpiler uses parser-mechanisms.lisp and v2mechanisms.lisp to support its operation.
* usage
  to build the transpiler (but doesn't build ../esa/cl-user-esa.lisp)
  ^C^C make (below)
* transpiler details
** The transpiler uses the PASM DSL (PASM is a low-level DSL for writing DSLs).
   Another DSL, stack-dsl, is used to compile exprtypes.dsl to exprtypes.lisp.  It
   defines the classes used in the esa-transpiler.
   See parsing-assembler for details about PASM.
   In the .pasm files for esa-transpiler, all passes use the same parser (copied and pasted).
   The .pasm files are split into two functions: (1) parsing and, (2) semantics.
   Semantic operations all begin with the "$" character and are found in
     mechanisms.lisp (automatically generated) and manual-mechanisms.lisp (hand built).
   Parsing operations are not further adorned.  The PASM transpiler adds a suffix to
     each parser routine (and call) which is specified explicitly as a string parameter
     to pasm:pasm-to-file.  This suffix allows each pass to use the same (copy/pasted)
     grammar without duplicating names in the namespace (CL packages are supposed to handle
     this kind of thing, but are not geared/intended for DSLs).
** The ESA transpiler consists of 4 passes.
   See exprtype.drawio for a diagram of the data structures handled by the passes.
** Pass 0 does almost nothing.  It parses esa.dsl and checks its syntax.  It produces no output if there are no syntax errors.
** Pass 1 produces an esaprogram class which is handed to pass 2.
   Pass 1 handles most declarations (classes, types, situations)
** Pass 2 
   Bolts methods (and scripts) to the appropriate classes.
** Pass 3
   Handles Script declarations (actual code) and finalizes the esaprogram structures.
** dsl0.pasm is pass 0.
** dsl1.pasm is pass 1
** dsl2.pasm is pass 2
** dsl3.pasm is pass 3
** print.lisp is an OO recursive descent tree walker on the esaprogram structure.  It produces a string containing Lisp code.
   print-pseudo.lisp is the same tree walker which produces a string of pseudo-code.
* cheating
** Much of the real type-checking work is left to the base (underlying) language, in this case Common Lisp.
** During bootstrap, I've left out many automate-able checks for brevity.  
   YAGNI.
   This thing needs to transpile only one file: esa.dsl.
   Actions (generalizations) that weren't on the critical path to getting a working esa.dsl->esa.lisp transpiler
     were (might have been) left out.  The implementation of missing checks should be "obvious".
     For my purposes, it is enough to get esa.lisp emitted and to manually check it for sanity.
* make.lisp
** make.lisp (make) builds all of the .lisp files for the transpiler 
#+name: esa
#+begin_src lisp :results output
  (progn
    (load "make")
    (make))
#+end_src
^^ if (make) is undefined, visit make.lisp and compile/load it (^C^K)

#+RESULTS: esa
#+begin_example
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (UIOP/RUN-PROGRAM:RUN-PROGRAM "~/quicklisp/local-projects/rm.bash"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0))))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :STACK-DSL))
To load "stack-dsl":
  Load 1 ASDF system:
    stack-dsl
; Loading "stack-dsl"
[package loops]...................................
[package alexandria.1.0.0]........................
[package json]....................................
[package json-rpc]................................
[package scanner].................................
[package parsing-assembler].......................
[package stack-dsl]
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :STACK-DSL/USE))
To load "stack-dsl/use":
  Load 1 ASDF system:
    stack-dsl/use
; Loading "stack-dsl/use"
[package cl-ppcre]................................
.......................................
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (STACK-DSL:TRANSPILE-STACK
  (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME :ARROWGRAMS
                                        "build_process/esa-transpiler/exprtypes.dsl")
  "CL-USER"
  (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME :ARROWGRAMS
                                        "build_process/esa-transpiler/exprtypes.lisp")
  (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME :ARROWGRAMS
                                        "build_process/esa-transpiler/exprtypes.json")
  "ARROWGRAMS/ESA-TRANSPILER" "CL-USER"
  (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME :ARROWGRAMS
                                        "build_process/esa-transpiler/mechanisms.lisp")))
in stack-dsl NIL NIL
,*** calling initially on stack-dsl-parser
,*** calling initially on stack-dsl-parser
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :PARSING-ASSEMBLER/USE))
To load "parsing-assembler/use":
  Load 1 ASDF system:
    parsing-assembler/use
; Loading "parsing-assembler/use"

(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PARSING-ASSEMBLER:PASM-TO-FILE "ARROWGRAMS/ESA-TRANSPILER"
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl0.pasm")
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl0.lisp")
                                 "-PASS0"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PARSING-ASSEMBLER:PASM-TO-FILE "ARROWGRAMS/ESA-TRANSPILER"
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl1.pasm")
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl1.lisp")
                                 "-PASS1"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PARSING-ASSEMBLER:PASM-TO-FILE "ARROWGRAMS/ESA-TRANSPILER"
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl2.pasm")
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl2.lisp")
                                 "-PASS2"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PARSING-ASSEMBLER:PASM-TO-FILE "ARROWGRAMS/ESA-TRANSPILER"
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl3.pasm")
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl3.lisp")
                                 "-PASS3"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :ARROWGRAMS/ESA-TRANSPILER))
To load "arrowgrams/esa-transpiler":
  Load 1 ASDF system:
    arrowgrams/esa-transpiler
; Loading "arrowgrams/esa-transpiler"
[package cl-event-passing]........................
[package cl-event-passing-user]...................
[package cl-event-passing-part]...................
[package cl-event-passing-event]..................
[package cl-event-passing-source].................
[package cl-event-passing-receiver]...............
[package cl-event-passing-schematic]..............
[package cl-event-passing-dispatch]...............
[package cl-event-passing-user-util]..............
[package cl-event-passing-user-wire]..............
[package cl-event-passing-pin]....................
[package arrowgrams/esa-transpiler]...............
...........................
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0))))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "package.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "classes.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "dsl0.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "dsl1.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "dsl2.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "dsl3.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "exprtypes.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "manual-types.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "emitLisp.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "mechanisms.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "manual-mechanisms.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "esa-transpile.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "trace-rules.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "trace-mechs.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :ARROWGRAMS/ESA-TRANSPILER))
To load "arrowgrams/esa-transpiler":
  Load 1 ASDF system:
    arrowgrams/esa-transpiler
; Loading "arrowgrams/esa-transpiler"

(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LET ()
   (STACK-DSL:INITIALIZE-TYPES
    (ARROWGRAMS/ESA-TRANSPILER:PATH "exprtypes.json"))
   (LET ((RESULT
          (ARROWGRAMS/ESA-TRANSPILER:TRANSPILE-ESA-TO-STRING
           (ARROWGRAMS/ESA-TRANSPILER:PATH "esa-test1.dsl") :TRACING-ACCEPT
           NIL)))
     (FORMAT *STANDARD-OUTPUT* "~&~a~%~%~%" RESULT))))
,* pass 0
,*** check stacks ***
,* pass 1
,*** check stacks ***
OUTPUT-ESAPROGRAM 1
,* pass 2
,*** check stacks ***
OUTPUT-ESAPROGRAM 1
OUTPUT-NAME 90
OUTPUT-EXPRESSION 85
,* pass 3
,*** check stacks ***
OUTPUT-ESAPROGRAM 1
OUTPUT-NAME 58

(defclass part-definition ()
(
(part-name :accessor part-name :initform nil)
(part-kind :accessor part-kind :initform nil)))
#| external method ((self part-definition)) ensure-kind-defined |#

(defclass named-part-instance ()
(
(instance-name :accessor instance-name :initform nil)
(instance-node :accessor instance-node :initform nil)))

(defclass part-pin ()
(
(part-name :accessor part-name :initform nil)
(pin-name :accessor pin-name :initform nil)))

(defclass source ()
(
(part-name :accessor part-name :initform nil)
(pin-name :accessor pin-name :initform nil)))
#| external method ((self source)) refers-to-self? |#

(defclass destination ()
(
(part-name :accessor part-name :initform nil)
(pin-name :accessor pin-name :initform nil)))
#| external method ((self destination)) refers-to-self? |#

(defclass wire ()
(
(index :accessor index :initform nil)
(sources :accessor sources :initform nil)
(destinations :accessor destinations :initform nil)))
#| external method ((self wire)) install-source |#
#| external method ((self wire)) install-destination |#
(defmethod add-source ((self wire) part pin)
        (install-source self part pin))
(defmethod add-destination ((self wire) part pin)
        (install-destination self part pin))

(defclass kind ()
(
(kind-name :accessor kind-name :initform nil)
(input-pins :accessor input-pins :initform nil)
(self-class :accessor self-class :initform nil)
(output-pins :accessor output-pins :initform nil)
(parts :accessor parts :initform nil)
(wires :accessor wires :initform nil)))
#| external method ((self kind)) install-input-pin |#
#| external method ((self kind)) install-output-pin |#
(defmethod add-input-pin ((self kind) name)
        (ensure-input-pin-not-declared self name)
        (install-input-pin self name))
(defmethod add-output-pin ((self kind) name)
        (ensure-output-pin-not-declared self name)
        (install-output-pin self name))
(defmethod add-part ((self kind) nm k nclass)
        (ensure-part-not-declared self nm)
        (install-part self nm k nclass))
(defmethod add-wire ((self kind) w)
        (block %map (dolist (s (sources w)) 
(ensure-valid-source self s)))
        (block %map (dolist (dest (destinations w)) 
(ensure-valid-destination self dest)))
        (install-wire self w))
#| external method ((self kind)) install-wire |#
#| external method ((self kind)) install-part |#
#| external method ((self kind)) parts |#
#| external method ((self kind)) install-class |#
#| external method ((self kind)) ensure-part-not-declared |#
#| external method ((self kind)) ensure-valid-input-pin |#
#| external method ((self kind)) ensure-valid-output-pin |#
#| external method ((self kind)) ensure-input-pin-not-declared |#
#| external method ((self kind)) ensure-output-pin-not-declared |#
(defmethod ensure-valid-source ((self kind) s)
        (if (esa-expr-true (refers-to-self? s))
(progn
(ensure-valid-input-pin self (pin-name s))
)
(progn
(let ((p (kind-find-part self (part-name s)))) 
(ensure-kind-defined p)
(ensure-valid-output-pin (part-kind p) (pin-name s)))
)))
(defmethod ensure-valid-destination ((self kind) dest)
        (if (esa-expr-true (refers-to-self? dest))
(progn
(ensure-valid-output-pin self (pin-name dest))
)
(progn
(let ((p (kind-find-part self (part-name dest)))) 
(ensure-kind-defined p)
(ensure-valid-input-pin (part-kind p) (pin-name dest)))
)))
(defmethod loader ((self kind) my-name my-container dispatchr)
        (let ((clss (self-class self))) 
(let ((inst (make-instance clss)))
(clear-input-queue inst)
(clear-output-queue inst)
(setf (kind-field inst) self)
(setf (container inst) my-container)
(setf (name-in-container inst) my-name)
(block %map (dolist (part (parts self)) 
(let ((part-instance (loader (part-kind part) (part-name part) inst dispatchr))) 
(add-child inst (part-name part) part-instance))))
(memo-node dispatchr inst)
(return-from loader inst))))
#| external method ((self kind)) find-wire-for-source |#
#| external method ((self kind)) find-wire-for-self-source |#

(defclass node ()
(
(input-queue :accessor input-queue :initform nil)
(output-queue :accessor output-queue :initform nil)
(kind-field :accessor kind-field :initform nil)
(container :accessor container :initform nil)
(name-in-container :accessor name-in-container :initform nil)
(children :accessor children :initform nil)
(busy-flag :accessor busy-flag :initform nil)))
#| external method ((self node)) clear-input-queue |#
#| external method ((self node)) clear-output-queue |#
#| external method ((self node)) install-node |#
(defmethod add-child ((self node) nm nd)
        (install-child self nm nd))
(defmethod initialize ((self node) )
        (initially self))
#| external method ((self node)) initially |#
#| external method ((self node)) send |#
(defmethod distribute-output-events ((self node) )
        (if (esa-expr-true (has-no-container? self))
(progn
(display-output-events-to-console-and-delete self)
)
(progn
(let ((parent-composite-node (container self))) 
(block %map (dolist (output (get-output-events-and-delete self)) 
(let ((dest (partpin output))) 
(let ((w (find-wire-for-source (kind-field parent-composite-node) (part-name (partpin output)) (pin-name (partpin output))))) 
(block %map (dolist (dest (destinations w)) 
(if (esa-expr-true (refers-to-self? dest))
(progn
(let ((new-event (make-instance 'event)))
(let ((pp (make-instance 'part-pin)))
(setf (part-name pp) (name-in-container parent-composite-node))
(setf (pin-name pp) (pin-name dest))
(setf (partpin new-event) pp)
(setf (data new-event) (data output))
(send parent-composite-node new-event)))
)
(progn
(let ((new-event (make-instance 'event)))
(let ((pp (make-instance 'part-pin)))
(setf (part-name pp) (part-name dest))
(setf (pin-name pp) (pin-name dest))
(setf (partpin new-event) pp)
(setf (data new-event) (data output))
(let ((child-part-instance (node-find-child parent-composite-node (part-name pp)))) 
(enqueue-input (instance-node child-part-instance) new-event))))
)))))))))
)))
#| external method ((self node)) display-output-events-to-console-and-delete |#
#| external method ((self node)) get-output-events-and-delete |#
#| external method ((self node)) has-no-container? |#
(defmethod distribute-outputs-upwards ((self node) )
        (if (esa-expr-true (has-no-container? self))
(progn
)
(progn
(let ((parent (container self))) 
(distribute-output-events parent))
)))
(defmethod busy? ((self node) )
        (if (esa-expr-true (flagged-as-busy? self))
(progn
(return-from busy? :true)
)
(progn
(block %map (dolist (child-part-instance (children self)) 
(let ((child-node (instance-node child-part-instance))) 
(if (esa-expr-true (has-inputs-or-outputs? child-node))
(progn
(return-from busy? :true)
)
(progn
(when (esa-expr-true (busy? child-node))
(return-from busy? :true)
)
)))))
))
        (return-from busy? :false))
(defmethod ready? ((self node) )
        (when (esa-expr-true (input-queue? self))
(if (esa-expr-true (busy? self))
(progn
(return-from ready? :false)
)
(progn
(return-from ready? :true)
))
)
        (return-from ready? :false))
(defmethod invoke ((self node) )
        (let ((e (dequeue-input self))) 
(run-reaction self e)
(distribute-output-events self)))
#| external method ((self node)) has-inputs-or-outputs? |#
#| external method ((self node)) children? |#
#| external method ((self node)) flagged-as-busy? |#
#| external method ((self node)) dequeue-input |#
#| external method ((self node)) input-queue? |#
#| external method ((self node)) enqueue-input |#
#| external method ((self node)) enqueue-output |#
#| external method ((self node)) react |#
(defmethod run-reaction ((self node) e)
        (react self e))
(defmethod run-composite-reaction ((self node) e)
        (let ((w :true)) 
(if (esa-expr-true (has-no-container? self))
(progn
(setf w (find-wire-for-self-source (kind-field self) (pin-name (partpin e))))
)
(progn
(setf w (find-wire-for-source (kind-field (container self)) (part-name (partpin e)) (pin-name (partpin e))))
))
(block %map (dolist (dest (destinations w)) 
(let ((new-event (make-instance 'event)))
(let ((pp (make-instance 'part-pin)))
(if (esa-expr-true (refers-to-self? dest))
(progn
(setf (part-name pp) (part-name dest))
(setf (pin-name pp) (pin-name dest))
(setf (partpin new-event) pp)
(setf (data new-event) (data e))
(send self new-event)
)
(progn
(when (esa-expr-true (children? self))
(setf (part-name pp) (part-name dest))
(setf (pin-name pp) (pin-name dest))
(setf (partpin new-event) pp)
(setf (data new-event) (data e))
(let ((child-part-instance (node-find-child self (part-name dest)))) 
(enqueue-input (instance-node child-part-instance) new-event))
)
))))))))
#| external method ((self node)) node-find-child |#

(defclass dispatcher ()
(
(all-parts :accessor all-parts :initform nil)
(top-node :accessor top-node :initform nil)))
#| external method ((self dispatcher)) memo-node |#
#| external method ((self dispatcher)) set-top-node |#
(defmethod initialize-all ((self dispatcher) )
        (block %map (dolist (part (all-parts self)) 
(initialize part))))
(defmethod start ((self dispatcher) )
        (distribute-all-outputs self)
        (run self))
(defmethod distribute-all-outputs ((self dispatcher) )
        (block %map (dolist (p (all-parts self)) 
(distribute-output-events p)
(distribute-outputs-upwards p))))
(defmethod run ((self dispatcher) )
        (let ((done :true)) 
(loop 
(setf done :true)
(distribute-all-outputs self)
(block %map (dolist (part (all-parts self)) 
(when (esa-expr-true (ready? part))
(invoke part)
(setf done :false)
(return-from %map :false)
)))
(when (esa-expr-true done) (return))))
        (declare-finished self))
#| external method ((self dispatcher)) declare-finished |#

(defclass event ()
(
(partpin :accessor partpin :initform nil)
(data :accessor data :initform nil)))



#+end_example
#+begin_example
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (UIOP/RUN-PROGRAM:RUN-PROGRAM "~/quicklisp/local-projects/rm.bash"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0))))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :STACK-DSL))
To load "stack-dsl":
  Load 1 ASDF system:
    stack-dsl
; Loading "stack-dsl"
[package loops]...................................
[package alexandria.1.0.0]........................
[package json]....................................
[package json-rpc]................................
[package scanner].................................
[package parsing-assembler].......................
[package stack-dsl]
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :STACK-DSL/USE))
To load "stack-dsl/use":
  Load 1 ASDF system:
    stack-dsl/use
; Loading "stack-dsl/use"
[package cl-ppcre]................................
.......................................
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (STACK-DSL:TRANSPILE-STACK
  (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME :ARROWGRAMS
                                        "build_process/esa-transpiler/exprtypes.dsl")
  "CL-USER"
  (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME :ARROWGRAMS
                                        "build_process/esa-transpiler/exprtypes.lisp")
  (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME :ARROWGRAMS
                                        "build_process/esa-transpiler/exprtypes.json")
  "ARROWGRAMS/ESA-TRANSPILER" "CL-USER"
  (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME :ARROWGRAMS
                                        "build_process/esa-transpiler/mechanisms.lisp")))
in stack-dsl NIL NIL
*** calling initially on stack-dsl-parser
*** calling initially on stack-dsl-parser
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :PARSING-ASSEMBLER/USE))
To load "parsing-assembler/use":
  Load 1 ASDF system:
    parsing-assembler/use
; Loading "parsing-assembler/use"

(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PARSING-ASSEMBLER:PASM-TO-FILE "ARROWGRAMS/ESA-TRANSPILER"
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl0.pasm")
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl0.lisp")
                                 "-PASS0"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PARSING-ASSEMBLER:PASM-TO-FILE "ARROWGRAMS/ESA-TRANSPILER"
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl1.pasm")
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl1.lisp")
                                 "-PASS1"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PARSING-ASSEMBLER:PASM-TO-FILE "ARROWGRAMS/ESA-TRANSPILER"
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl2.pasm")
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl2.lisp")
                                 "-PASS2"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PARSING-ASSEMBLER:PASM-TO-FILE "ARROWGRAMS/ESA-TRANSPILER"
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl3.pasm")
                                 (ASDF/SYSTEM:SYSTEM-RELATIVE-PATHNAME
                                  :ARROWGRAMS
                                  "build_process/esa-transpiler/dsl3.lisp")
                                 "-PASS3"))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :ARROWGRAMS/ESA-TRANSPILER))
To load "arrowgrams/esa-transpiler":
  Load 1 ASDF system:
    arrowgrams/esa-transpiler
; Loading "arrowgrams/esa-transpiler"
[package cl-event-passing]........................
[package cl-event-passing-user]...................
[package cl-event-passing-part]...................
[package cl-event-passing-event]..................
[package cl-event-passing-source].................
[package cl-event-passing-receiver]...............
[package cl-event-passing-schematic]..............
[package cl-event-passing-dispatch]...............
[package cl-event-passing-user-util]..............
[package cl-event-passing-user-wire]..............
[package cl-event-passing-pin]....................
[package arrowgrams/esa-transpiler]...............
...........................
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0))))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "package.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "classes.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "dsl0.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "dsl1.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "dsl2.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "dsl3.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "exprtypes.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "manual-types.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "emitLisp.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "mechanisms.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "manual-mechanisms.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "esa-transpile.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "trace-rules.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LOAD (ARROWGRAMS/ESA-TRANSPILER:PATH "trace-mechs.lisp")))
(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (QUICKLISP-CLIENT:QUICKLOAD :ARROWGRAMS/ESA-TRANSPILER))
To load "arrowgrams/esa-transpiler":
  Load 1 ASDF system:
    arrowgrams/esa-transpiler
; Loading "arrowgrams/esa-transpiler"

(PROGN
 (PROCLAIM '(OPTIMIZE (DEBUG 3) (SAFETY 3) (SPEED 0)))
 (LET ()
   (STACK-DSL:INITIALIZE-TYPES
    (ARROWGRAMS/ESA-TRANSPILER:PATH "exprtypes.json"))
   (LET ((RESULT
          (ARROWGRAMS/ESA-TRANSPILER:TRANSPILE-ESA-TO-STRING
           (ARROWGRAMS/ESA-TRANSPILER:PATH "esa-test1.dsl") :TRACING-ACCEPT
           NIL)))
     (FORMAT *STANDARD-OUTPUT* "~&~a~%~%~%" RESULT))))
* pass 0
*** check stacks ***
* pass 1
*** check stacks ***
OUTPUT-ESAPROGRAM 1
* pass 2
*** check stacks ***
OUTPUT-ESAPROGRAM 1
OUTPUT-NAME 90
OUTPUT-EXPRESSION 85
* pass 3
*** check stacks ***
OUTPUT-ESAPROGRAM 1
OUTPUT-NAME 58

(defclass part-definition ()
(
(part-name :accessor part-name :initform nil)
(part-kind :accessor part-kind :initform nil)))
#| external method ((self part-definition)) ensure-kind-defined |#

(defclass named-part-instance ()
(
(instance-name :accessor instance-name :initform nil)
(instance-node :accessor instance-node :initform nil)))

(defclass part-pin ()
(
(part-name :accessor part-name :initform nil)
(pin-name :accessor pin-name :initform nil)))

(defclass source ()
(
(part-name :accessor part-name :initform nil)
(pin-name :accessor pin-name :initform nil)))
#| external method ((self source)) refers-to-self? |#

(defclass destination ()
(
(part-name :accessor part-name :initform nil)
(pin-name :accessor pin-name :initform nil)))
#| external method ((self destination)) refers-to-self? |#

(defclass wire ()
(
(index :accessor index :initform nil)
(sources :accessor sources :initform nil)
(destinations :accessor destinations :initform nil)))
#| external method ((self wire)) install-source |#
#| external method ((self wire)) install-destination |#
(defmethod add-source ((self wire) part pin)
        (install-source self part pin))
(defmethod add-destination ((self wire) part pin)
        (install-destination self part pin))

(defclass kind ()
(
(kind-name :accessor kind-name :initform nil)
(input-pins :accessor input-pins :initform nil)
(self-class :accessor self-class :initform nil)
(output-pins :accessor output-pins :initform nil)
(parts :accessor parts :initform nil)
(wires :accessor wires :initform nil)))
#| external method ((self kind)) install-input-pin |#
#| external method ((self kind)) install-output-pin |#
(defmethod add-input-pin ((self kind) name)
        (ensure-input-pin-not-declared self name)
        (install-input-pin self name))
(defmethod add-output-pin ((self kind) name)
        (ensure-output-pin-not-declared self name)
        (install-output-pin self name))
(defmethod add-part ((self kind) nm k nclass)
        (ensure-part-not-declared self nm)
        (install-part self nm k nclass))
(defmethod add-wire ((self kind) w)
        (block %map (dolist (s (sources w)) 
(ensure-valid-source self s)))
        (block %map (dolist (dest (destinations w)) 
(ensure-valid-destination self dest)))
        (install-wire self w))
#| external method ((self kind)) install-wire |#
#| external method ((self kind)) install-part |#
#| external method ((self kind)) parts |#
#| external method ((self kind)) install-class |#
#| external method ((self kind)) ensure-part-not-declared |#
#| external method ((self kind)) ensure-valid-input-pin |#
#| external method ((self kind)) ensure-valid-output-pin |#
#| external method ((self kind)) ensure-input-pin-not-declared |#
#| external method ((self kind)) ensure-output-pin-not-declared |#
(defmethod ensure-valid-source ((self kind) s)
        (if (esa-expr-true (refers-to-self? s))
(progn
(ensure-valid-input-pin self (pin-name s))
)
(progn
(let ((p (kind-find-part self (part-name s)))) 
(ensure-kind-defined p)
(ensure-valid-output-pin (part-kind p) (pin-name s)))
)))
(defmethod ensure-valid-destination ((self kind) dest)
        (if (esa-expr-true (refers-to-self? dest))
(progn
(ensure-valid-output-pin self (pin-name dest))
)
(progn
(let ((p (kind-find-part self (part-name dest)))) 
(ensure-kind-defined p)
(ensure-valid-input-pin (part-kind p) (pin-name dest)))
)))
(defmethod loader ((self kind) my-name my-container dispatchr)
        (let ((clss (self-class self))) 
(let ((inst (make-instance clss)))
(clear-input-queue inst)
(clear-output-queue inst)
(setf (kind-field inst) self)
(setf (container inst) my-container)
(setf (name-in-container inst) my-name)
(block %map (dolist (part (parts self)) 
(let ((part-instance (loader (part-kind part) (part-name part) inst dispatchr))) 
(add-child inst (part-name part) part-instance))))
(memo-node dispatchr inst)
(return-from loader inst))))
#| external method ((self kind)) find-wire-for-source |#
#| external method ((self kind)) find-wire-for-self-source |#

(defclass node ()
(
(input-queue :accessor input-queue :initform nil)
(output-queue :accessor output-queue :initform nil)
(kind-field :accessor kind-field :initform nil)
(container :accessor container :initform nil)
(name-in-container :accessor name-in-container :initform nil)
(children :accessor children :initform nil)
(busy-flag :accessor busy-flag :initform nil)))
#| external method ((self node)) clear-input-queue |#
#| external method ((self node)) clear-output-queue |#
#| external method ((self node)) install-node |#
(defmethod add-child ((self node) nm nd)
        (install-child self nm nd))
(defmethod initialize ((self node) )
        (initially self))
#| external method ((self node)) initially |#
#| external method ((self node)) send |#
(defmethod distribute-output-events ((self node) )
        (if (esa-expr-true (has-no-container? self))
(progn
(display-output-events-to-console-and-delete self)
)
(progn
(let ((parent-composite-node (container self))) 
(block %map (dolist (output (get-output-events-and-delete self)) 
(let ((dest (partpin output))) 
(let ((w (find-wire-for-source (kind-field parent-composite-node) (part-name (partpin output)) (pin-name (partpin output))))) 
(block %map (dolist (dest (destinations w)) 
(if (esa-expr-true (refers-to-self? dest))
(progn
(let ((new-event (make-instance 'event)))
(let ((pp (make-instance 'part-pin)))
(setf (part-name pp) (name-in-container parent-composite-node))
(setf (pin-name pp) (pin-name dest))
(setf (partpin new-event) pp)
(setf (data new-event) (data output))
(send parent-composite-node new-event)))
)
(progn
(let ((new-event (make-instance 'event)))
(let ((pp (make-instance 'part-pin)))
(setf (part-name pp) (part-name dest))
(setf (pin-name pp) (pin-name dest))
(setf (partpin new-event) pp)
(setf (data new-event) (data output))
(let ((child-part-instance (node-find-child parent-composite-node (part-name pp)))) 
(enqueue-input (instance-node child-part-instance) new-event))))
)))))))))
)))
#| external method ((self node)) display-output-events-to-console-and-delete |#
#| external method ((self node)) get-output-events-and-delete |#
#| external method ((self node)) has-no-container? |#
(defmethod distribute-outputs-upwards ((self node) )
        (if (esa-expr-true (has-no-container? self))
(progn
)
(progn
(let ((parent (container self))) 
(distribute-output-events parent))
)))
(defmethod busy? ((self node) )
        (if (esa-expr-true (flagged-as-busy? self))
(progn
(return-from busy? :true)
)
(progn
(block %map (dolist (child-part-instance (children self)) 
(let ((child-node (instance-node child-part-instance))) 
(if (esa-expr-true (has-inputs-or-outputs? child-node))
(progn
(return-from busy? :true)
)
(progn
(when (esa-expr-true (busy? child-node))
(return-from busy? :true)
)
)))))
))
        (return-from busy? :false))
(defmethod ready? ((self node) )
        (when (esa-expr-true (input-queue? self))
(if (esa-expr-true (busy? self))
(progn
(return-from ready? :false)
)
(progn
(return-from ready? :true)
))
)
        (return-from ready? :false))
(defmethod invoke ((self node) )
        (let ((e (dequeue-input self))) 
(run-reaction self e)
(distribute-output-events self)))
#| external method ((self node)) has-inputs-or-outputs? |#
#| external method ((self node)) children? |#
#| external method ((self node)) flagged-as-busy? |#
#| external method ((self node)) dequeue-input |#
#| external method ((self node)) input-queue? |#
#| external method ((self node)) enqueue-input |#
#| external method ((self node)) enqueue-output |#
#| external method ((self node)) react |#
(defmethod run-reaction ((self node) e)
        (react self e))
(defmethod run-composite-reaction ((self node) e)
        (let ((w :true)) 
(if (esa-expr-true (has-no-container? self))
(progn
(setf w (find-wire-for-self-source (kind-field self) (pin-name (partpin e))))
)
(progn
(setf w (find-wire-for-source (kind-field (container self)) (part-name (partpin e)) (pin-name (partpin e))))
))
(block %map (dolist (dest (destinations w)) 
(let ((new-event (make-instance 'event)))
(let ((pp (make-instance 'part-pin)))
(if (esa-expr-true (refers-to-self? dest))
(progn
(setf (part-name pp) (part-name dest))
(setf (pin-name pp) (pin-name dest))
(setf (partpin new-event) pp)
(setf (data new-event) (data e))
(send self new-event)
)
(progn
(when (esa-expr-true (children? self))
(setf (part-name pp) (part-name dest))
(setf (pin-name pp) (pin-name dest))
(setf (partpin new-event) pp)
(setf (data new-event) (data e))
(let ((child-part-instance (node-find-child self (part-name dest)))) 
(enqueue-input (instance-node child-part-instance) new-event))
)
))))))))
#| external method ((self node)) node-find-child |#

(defclass dispatcher ()
(
(all-parts :accessor all-parts :initform nil)
(top-node :accessor top-node :initform nil)))
#| external method ((self dispatcher)) memo-node |#
#| external method ((self dispatcher)) set-top-node |#
(defmethod initialize-all ((self dispatcher) )
        (block %map (dolist (part (all-parts self)) 
(initialize part))))
(defmethod start ((self dispatcher) )
        (distribute-all-outputs self)
        (run self))
(defmethod distribute-all-outputs ((self dispatcher) )
        (block %map (dolist (p (all-parts self)) 
(distribute-output-events p)
(distribute-outputs-upwards p))))
(defmethod run ((self dispatcher) )
        (let ((done :true)) 
(loop 
(setf done :true)
(distribute-all-outputs self)
(block %map (dolist (part (all-parts self)) 
(when (esa-expr-true (ready? part))
(invoke part)
(setf done :false)
(return-from %map :false)
)))
(when (esa-expr-true done) (return))))
        (declare-finished self))
#| external method ((self dispatcher)) declare-finished |#

(defclass event ()
(
(partpin :accessor partpin :initform nil)
(data :accessor data :initform nil)))



#+end_example

