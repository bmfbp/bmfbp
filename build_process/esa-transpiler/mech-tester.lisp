(in-package :arrowgrams/esa-transpiler)

(defun test-esa-to-string (esa-input-filename &key (tracing-accept nil))
  (let ((in-string (alexandria:read-file-into-string esa-input-filename)))
    (let ((token-stream (scanner:scanner in-string)))
      (let ((p (make-instance 'arrowgrams/esa-transpiler::parser)))
	(pasm:initially p token-stream)
	;(esa-dsl p)  ;; call top rule
	(let ((pasm::*pasm-accept-tracing* tracing-accept))
	  (tester p))  ;; call tester rule during development
	               ;; it calls $mech-test below
	(let ((result (get-output-stream-string (pasm:output-string-stream p))))
	  (concatenate 'string 
		       (format nil "(in-package :esa)~%~%")
		       result)
	  result)))))

(defun test-esa-to-file (esa-input-filename output-filename &key (tracing-accept nil))
  (let ((str (test-esa-to-string esa-input-filename :tracing-accept tracing-accept)))
    (with-open-file (outf output-filename :direction :output :if-exists :supersede :if-does-not-exist :create)
      (write-string str outf))))

(defmethod $mech-tester ((p parser))
  ;; self.fn(x)
  ;; results in one object that has one field (with a parameterList of length 1)
  ;; re-compile using ~/quicklisp/local-projects/hier/README.org whenever exprtypes.dsl is changed

  ($expression__NewScope p)
    ($ekind__NewScope p)
      ($ekind__SetEnum_object p)
    ($ekind__Output p)
    ($object__NewScope p)
      ($name__NewScope p)
        ($name__GetName p)
      ($name__Output p)
      ($fieldMap__NewScope p)
        ($%map__NewScope p)
          ($field__NewScope p)
            ($name__NewScope p)
              ($name__GetName p)
            ($name__Output p)
            ($parameterList__NewScope p)
              ($%map__NewScope p)
                ($name__NewScope p)
                  ($name__GetName p)
                ($name__Output p)
                ($%map__AppendFrom_name p)
              ($%map__Output p)
            ($parameterList__Output p)
          ($field__Output p)
          ($%map__AppendFrom_field p)
        ($%map__Output p)
      ($fieldMap__Output p)
    ($object__Output p)
  ($expression__Output p)

  )
