(in-package "CL-USER")

(defclass expression (stack-dsl::%typed-value)
((%field-type-object :accessor %field-type-object :initform "object")
(object :accessor object)
(%field-type-kind :accessor %field-type-kind :initform "kind")
(kind :accessor kind)
) (:default-initargs :%type "expression"))

(defclass expression-stack (stack-dsl::%typed-stack) ())
(defmethod initialize-instance :after ((self expression-stack) &key &allow-other-keys)
  (setf (stack-dsl::%element-type self) "expression"))


(defclass kind (%enum) () (:default-initargs :%type "kind"))

(defmethod initialize-instance :after ((self kind) &key &allow-other-keys)
  (setf (stack-dsl::%value-list self) '("object" "false" "true")))


(defclass kind-stack (stack-dsl::%typed-stack) ())
(defmethod initialize-instance :after ((self kind-stack) &key &allow-other-keys)
  (setf (stack-dsl::%element-type self) "kind"))
(defclass object (stack-dsl::%typed-value)
((%field-type-fieldMap :accessor %field-type-fieldMap :initform "fieldMap")
(fieldMap :accessor fieldMap)
(%field-type-name :accessor %field-type-name :initform "name")
(name :accessor name)
) (:default-initargs :%type "object"))

(defclass object-stack (stack-dsl::%typed-stack) ())
(defmethod initialize-instance :after ((self object-stack) &key &allow-other-keys)
  (setf (stack-dsl::%element-type self) "object"))


(defclass name (stack-dsl::%string) () (:default-initargs :%type "name"))
(defclass name-stack (stack-dsl::%typed-stack) ())
(defmethod initialize-instance :after ((self name-stack) &key &allow-other-keys)
  (setf (stack-dsl::%element-type self) "name"))

(defclass fieldMap (stack-dsl::%map) () (:default-initargs :%type "fieldMap"))
(defmethod initialize-instance :after ((self fieldMap) &key &allow-other-keys)  ;; type for items in map
(setf (stack-dsl::%element-type self) "fieldMap"))
(defclass fieldMap-stack(stack-dsl::%typed-stack) ())
 (defmethod initialize-instance :after ((self fieldMap-stack) &key &allow-other-keys)
(setf (stack-dsl::%element-type self) "fieldMap"))
(defclass field (stack-dsl::%typed-value)
((%field-type-parameterList :accessor %field-type-parameterList :initform "parameterList")
(parameterList :accessor parameterList)
(%field-type-name :accessor %field-type-name :initform "name")
(name :accessor name)
) (:default-initargs :%type "field"))

(defclass field-stack (stack-dsl::%typed-stack) ())
(defmethod initialize-instance :after ((self field-stack) &key &allow-other-keys)
  (setf (stack-dsl::%element-type self) "field"))


(defclass parameterList (stack-dsl::%compound-type) () (:default-initargs :%type "parameterList"))
(defmethod initialize-instance :after ((self parameterList) &key &allow-other-keys)
  (setf (stack-dsl::%type-list self) '("nameList" "empty")))
(defclass parameterList-stack (stack-dsl::%typed-stack) () (:default-initargs :%element-type "parameterList"))

(defclass nameList (stack-dsl::%map) () (:default-initargs :%type "nameList"))
(defmethod initialize-instance :after ((self nameList) &key &allow-other-keys)  ;; type for items in map
(setf (stack-dsl::%element-type self) "nameList"))
(defclass nameList-stack(stack-dsl::%typed-stack) ())
 (defmethod initialize-instance :after ((self nameList-stack) &key &allow-other-keys)
(setf (stack-dsl::%element-type self) "nameList"))

(defclass empty (stack-dsl::%null) () (:default-initargs :%type "empty"))
(defclass empty-stack (stack-dsl::%typed-stack) ())
(defmethod initialize-instance :after ((self empty-stack) &key &allow-other-keys)
  (setf (stack-dsl::%element-type self) "empty"))



;; check forward types
(stack-dsl::%ensure-existence 'expression)
(stack-dsl::%ensure-existence 'kind)
(stack-dsl::%ensure-existence 'object)
(stack-dsl::%ensure-existence 'name)
(stack-dsl::%ensure-existence 'fieldMap)
(stack-dsl::%ensure-existence 'field)
(stack-dsl::%ensure-existence 'parameterList)
(stack-dsl::%ensure-existence 'empty)
(stack-dsl::%ensure-existence 'nameList)

(defclass environment ()
((%water-mark :accessor %water-mark :initform nil)
(input-expression :accessor input-expression :initform (make-instance 'expression-stack))
(output-expression :accessor output-expression :initform (make-instance 'expression-stack))
(input-kind :accessor input-kind :initform (make-instance 'kind-stack))
(output-kind :accessor output-kind :initform (make-instance 'kind-stack))
(input-object :accessor input-object :initform (make-instance 'object-stack))
(output-object :accessor output-object :initform (make-instance 'object-stack))
(input-name :accessor input-name :initform (make-instance 'name-stack))
(output-name :accessor output-name :initform (make-instance 'name-stack))
(input-fieldMap :accessor input-fieldMap :initform (make-instance 'fieldMap-stack))
(output-fieldMap :accessor output-fieldMap :initform (make-instance 'fieldMap-stack))
(input-field :accessor input-field :initform (make-instance 'field-stack))
(output-field :accessor output-field :initform (make-instance 'field-stack))
(input-parameterList :accessor input-parameterList :initform (make-instance 'parameterList-stack))
(output-parameterList :accessor output-parameterList :initform (make-instance 'parameterList-stack))
(input-empty :accessor input-empty :initform (make-instance 'empty-stack))
(output-empty :accessor output-empty :initform (make-instance 'empty-stack))
(input-nameList :accessor input-nameList :initform (make-instance 'nameList-stack))
(output-nameList :accessor output-nameList :initform (make-instance 'nameList-stack))
))

(defmethod %memoStacks ((self environment))
(setf (%water-mark self)
(list
(input-expression self)
(output-expression self)
(input-kind self)
(output-kind self)
(input-object self)
(output-object self)
(input-name self)
(output-name self)
(input-fieldMap self)
(output-fieldMap self)
(input-field self)
(output-field self)
(input-parameterList self)
(output-parameterList self)
(input-empty self)
(output-empty self)
(input-nameList self)
(output-nameList self)
)))

(defmethod %memoCheck ((self environment))
(let ((wm (%water-mark self)))
(unless (and
(eq (nth 0 wm) (input-expression self))
(eq (nth 1 wm) (output-expression self))
(eq (nth 2 wm) (input-kind self))
(eq (nth 3 wm) (output-kind self))
(eq (nth 4 wm) (input-object self))
(eq (nth 5 wm) (output-object self))
(eq (nth 6 wm) (input-name self))
(eq (nth 7 wm) (output-name self))
(eq (nth 8 wm) (input-fieldMap self))
(eq (nth 9 wm) (output-fieldMap self))
(eq (nth 10 wm) (input-field self))
(eq (nth 11 wm) (output-field self))
(eq (nth 12 wm) (input-parameterList self))
(eq (nth 13 wm) (output-parameterList self))
(eq (nth 14 wm) (input-empty self))
(eq (nth 15 wm) (output-empty self))
(eq (nth 16 wm) (input-nameList self))
(eq (nth 17 wm) (output-nameList self))
))
(error "stack depth incorrect")))
