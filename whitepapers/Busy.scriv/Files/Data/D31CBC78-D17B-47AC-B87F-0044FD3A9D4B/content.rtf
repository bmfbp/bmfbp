{\rtf1\ansi\ansicpg1252\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\froman\fcharset0 Palatino-Italic;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f0\fs26 \cf0 Every Part is 
\f1\i busy
\f0\i0  until while it is processing a (single) input event.\
\
Determination of 
\f1\i busy
\f0\i0  is straight-forward for {\field{\*\fldinst{HYPERLINK "scrivcmt://EF9032B4-80EA-417B-966C-9E4F896D9D98"}}{\fldrslt 
\f1\i leaf}}
\f1\i  
\f0\i0 parts.  Leaf parts are invoked by call-return for each input event.  Leaf parts are always observed to be non-
\f1\i busy 
\f0\i0 (using call/return, the leaf part is 
\f1\i busy
\f0\i0  if it is reacting to an event).\
\
S{\field{\*\fldinst{HYPERLINK "scrivcmt://3F8BFD7B-04FF-4D9A-9646-C031B10B9F0B"}}{\fldrslt 
\f1\i chematic}} parts, on the other hand, are 
\f1\i busy
\f0\i0  if \ul any\ulnone  of their children are busy.  This must be determined by a recursive call at runtime.\
\
\pard\tx360\tx720\tx1080\tx1440\tx1800\tx2160\tx2880\tx3600\tx4320\fi360\sl264\slmult1\pardirnatural\partightenfactor0

\f1\i \cf0 Busy
\f0\i0 ness is also more interesting on bare metal and multi-core implementations, or anywhere that an interrupt can {\field{\*\fldinst{HYPERLINK "scrivcmt://39656DFA-F06F-43C2-BF9E-AD4F918F7862"}}{\fldrslt occur}}.  In such cases, 
\f1\i busy
\f0\i0  is kept as an explicit bit flag.  The driver software needs to query the busy flag and, if the receiving part is 
\f1\i busy, 
\f0\i0  then the driver simply enqueues the incoming event onto the input queue of the part.  If the part is not 
\f1\i busy
\f0\i0 , the event is enqueued and the dispatcher is started.}