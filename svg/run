#!/bin/bash -x
# script that runs the components manually w/o grash and leaves intermediate files, for debug purposes export
# export LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:$LIBRARY_PATH
PATH=/usr/local/bin/:~/bin/:$PATH
BINDIR=~/bin

# gplc pl_match_ports_to_components.pl --no-top-level
# mv ./pl_check_input ${BINDIR}

gplc pl_kinds.pl --no-top-level
mv ./pl_kinds ${BINDIR}

# build the svg_compiler using a yEd diagram
# depends on some of pl_* files built in ../pl_vsh and placed in BINDIR
plscan svg_compiler.graphml >svg_compiler.pro
sort svg_compiler.pro >fb1.pro
pl_check_input <fb1.pro >fb2.pro
pl_calc_bounds <fb2.pro >fb3.pro
pl_mark_directions <fb3.pro >fb4.pro
pl_match_ports_to_components <fb4.pro >fb5.pro
pl_assign_pipe_numbers_to_inputs <fb5.pro >fb6.pro
pl_assign_pipe_numbers_to_outputs <fb6.pro >fb7.pro
pl_assign_fds <fb7.pro >fb8.pro
pl_emit <fb8.pro >svg_vsh.gsh

# now build the svg sample into sample.gsh
echo "component(top)." >sample.pro
parsed-svg-to-fb <sample.lisp >>sample.pro
sort sample.pro >sample1.pro

# grash svg_vsh.gsh <sample1.pro >sample.gsh

# construct manually during debug
pl_check_input <sample1.pro >sample2.pro
pl_calc_bounds <sample2.pro >sample3.pro
pl_kinds <sample3.pro >sample3a.pro
pl_mark_directions <sample3a.pro >sample4.pro
pl_match_ports_to_components <sample4.pro >sample5.pro
pl_assign_pipe_numbers_to_inputs <sample5.pro >sample6.pro
pl_assign_pipe_numbers_to_outputs <sample6.pro >sample7.pro
pl_assign_fds <sample7.pro >sample8.pro
pl_emit <sample8.pro >sample.gsh

